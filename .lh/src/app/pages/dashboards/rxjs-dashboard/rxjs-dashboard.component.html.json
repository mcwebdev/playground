{
    "sourceFile": "src/app/pages/dashboards/rxjs-dashboard/rxjs-dashboard.component.html",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1692725995968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1692726015869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,2 +1,3 @@\n <p>rxjs-dashboard works!</p>\n <pre><code class=\"language-html\" [highlight]=\"code\"></code></pre>\n+<pre><code class=\"language-html\" [highlight]=\"code1\"></code></pre>\n"
                },
                {
                    "date": 1692726177861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3 +1,23 @@\n-<p>rxjs-dashboard works!</p>\n+<h1>RxJS Operators</h1>\n+\n+<h2>mergeMap</h2>\n+<p><strong>Alias:</strong> flatMap</p>\n+<p><strong>Behavior:</strong> It takes a value from the source observable and maps it to a new inner observable. The\n+    values from all active inner observables are then emitted as they arrive.</p>\n+<p><strong>Concurrency:</strong> All inner observables are subscribed to concurrently. Values are emitted from the inner\n+    observables as they arrive, regardless of the order of source values.</p>\n+<p><strong>Use Case:</strong> When you want to perform a side effect for each value from the source and care about all\n+    resulting values.</p>\n+\n+<h2>switchMap</h2>\n+<p><strong>Behavior:</strong> Like mergeMap, it maps each value to a new observable. However, it unsubscribes from the\n+    previously mapped observable when a new value arrives from the source.</p>\n+<p><strong>Concurrency:</strong> Only one inner observable is active at a time. When a new inner observable is created,\n+    the previous one is unsubscribed from, and its values are ignored.</p>\n+<p><strong>Use Case:</strong> When you want to perform a side effect for the latest value and ignore any previously\n+    pending async operations.</p>\n+\n+<h2>Code Examples</h2>\n+<p>Here's a comparison using code snippets:</p>\n <pre><code class=\"language-html\" [highlight]=\"code\"></code></pre>\n <pre><code class=\"language-html\" [highlight]=\"code1\"></code></pre>\n"
                },
                {
                    "date": 1692726231706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,17 +7,14 @@\n <p><strong>Concurrency:</strong> All inner observables are subscribed to concurrently. Values are emitted from the inner\n     observables as they arrive, regardless of the order of source values.</p>\n <p><strong>Use Case:</strong> When you want to perform a side effect for each value from the source and care about all\n     resulting values.</p>\n-\n+<pre><code class=\"language-html\" [highlight]=\"code\"></code></pre>\n <h2>switchMap</h2>\n <p><strong>Behavior:</strong> Like mergeMap, it maps each value to a new observable. However, it unsubscribes from the\n     previously mapped observable when a new value arrives from the source.</p>\n <p><strong>Concurrency:</strong> Only one inner observable is active at a time. When a new inner observable is created,\n     the previous one is unsubscribed from, and its values are ignored.</p>\n <p><strong>Use Case:</strong> When you want to perform a side effect for the latest value and ignore any previously\n     pending async operations.</p>\n \n-<h2>Code Examples</h2>\n-<p>Here's a comparison using code snippets:</p>\n-<pre><code class=\"language-html\" [highlight]=\"code\"></code></pre>\n <pre><code class=\"language-html\" [highlight]=\"code1\"></code></pre>\n"
                },
                {
                    "date": 1692726634941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n     observables as they arrive, regardless of the order of source values.</p>\n <p><strong>Use Case:</strong> When you want to perform a side effect for each value from the source and care about all\n     resulting values.</p>\n <pre><code class=\"language-html\" [highlight]=\"code\"></code></pre>\n+<pre><code class=\"language-html\" [highlight]=\"code2\"></code></pre>\n <h2>switchMap</h2>\n <p><strong>Behavior:</strong> Like mergeMap, it maps each value to a new observable. However, it unsubscribes from the\n     previously mapped observable when a new value arrives from the source.</p>\n <p><strong>Concurrency:</strong> Only one inner observable is active at a time. When a new inner observable is created,\n@@ -17,4 +18,5 @@\n <p><strong>Use Case:</strong> When you want to perform a side effect for the latest value and ignore any previously\n     pending async operations.</p>\n \n <pre><code class=\"language-html\" [highlight]=\"code1\"></code></pre>\n+<pre><code class=\"language-html\" [highlight]=\"code3\"></code></pre>\n"
                },
                {
                    "date": 1692727399628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,4 +19,21 @@\n     pending async operations.</p>\n \n <pre><code class=\"language-html\" [highlight]=\"code1\"></code></pre>\n <pre><code class=\"language-html\" [highlight]=\"code3\"></code></pre>\n+\n+<h4>mergeMap Complex Case: Loading Multiple Dependencies Concurrently</h4>\n+<p>Imagine an application where you need to load multiple dependent resources from various endpoints. These resources might\n+include user information, user's posts, friends' information, etc. You want to initiate these requests concurrently, and\n+you're interested in handling all the results, not just the latest one.\n+</p>\n+<pre><code class=\"language-html\" [highlight]=\"code4\"></code></pre>\n+<strong>Summary:</strong>\n+<p>In this example, mergeMap is used to initiate multiple dependent requests concurrently. The results from all of these\n+requests are important, and they are handled separately.</p>\n+\n+<p>This contrasts with a use case for switchMap, where you would only be interested in the result of the latest observable.\n+By using mergeMap, you're able to handle complex scenarios where multiple concurrent operations are required, and all\n+results are relevant.</p>\n+\n+<p>This pattern is particularly useful in applications where various parts of the UI depend on different data sets, and you\n+want to initiate loading of these data sets concurrently to optimize the loading time.</p>\n"
                },
                {
                    "date": 1692727406729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,44 +1,67 @@\n <h1>RxJS Operators</h1>\n \n <h2>mergeMap</h2>\n <p><strong>Alias:</strong> flatMap</p>\n-<p><strong>Behavior:</strong> It takes a value from the source observable and maps it to a new inner observable. The\n-    values from all active inner observables are then emitted as they arrive.</p>\n-<p><strong>Concurrency:</strong> All inner observables are subscribed to concurrently. Values are emitted from the inner\n-    observables as they arrive, regardless of the order of source values.</p>\n-<p><strong>Use Case:</strong> When you want to perform a side effect for each value from the source and care about all\n-    resulting values.</p>\n+<p>\n+  <strong>Behavior:</strong> It takes a value from the source observable and\n+  maps it to a new inner observable. The values from all active inner\n+  observables are then emitted as they arrive.\n+</p>\n+<p>\n+  <strong>Concurrency:</strong> All inner observables are subscribed to\n+  concurrently. Values are emitted from the inner observables as they arrive,\n+  regardless of the order of source values.\n+</p>\n+<p>\n+  <strong>Use Case:</strong> When you want to perform a side effect for each\n+  value from the source and care about all resulting values.\n+</p>\n <pre><code class=\"language-html\" [highlight]=\"code\"></code></pre>\n <pre><code class=\"language-html\" [highlight]=\"code2\"></code></pre>\n <h2>switchMap</h2>\n-<p><strong>Behavior:</strong> Like mergeMap, it maps each value to a new observable. However, it unsubscribes from the\n-    previously mapped observable when a new value arrives from the source.</p>\n-<p><strong>Concurrency:</strong> Only one inner observable is active at a time. When a new inner observable is created,\n-    the previous one is unsubscribed from, and its values are ignored.</p>\n-<p><strong>Use Case:</strong> When you want to perform a side effect for the latest value and ignore any previously\n-    pending async operations.</p>\n+<p>\n+  <strong>Behavior:</strong> Like mergeMap, it maps each value to a new\n+  observable. However, it unsubscribes from the previously mapped observable\n+  when a new value arrives from the source.\n+</p>\n+<p>\n+  <strong>Concurrency:</strong> Only one inner observable is active at a time.\n+  When a new inner observable is created, the previous one is unsubscribed from,\n+  and its values are ignored.\n+</p>\n+<p>\n+  <strong>Use Case:</strong> When you want to perform a side effect for the\n+  latest value and ignore any previously pending async operations.\n+</p>\n \n <pre><code class=\"language-html\" [highlight]=\"code1\"></code></pre>\n <pre><code class=\"language-html\" [highlight]=\"code3\"></code></pre>\n \n <h4>mergeMap Complex Case: Loading Multiple Dependencies Concurrently</h4>\n-<p>Imagine an application where you need to load multiple dependent resources from various endpoints. These resources\n-    might\n-    include user information, user's posts, friends' information, etc. You want to initiate these requests concurrently,\n-    and\n-    you're interested in handling all the results, not just the latest one.\n+<p>\n+  Imagine an application where you need to load multiple dependent resources\n+  from various endpoints. These resources might include user information, user's\n+  posts, friends' information, etc. You want to initiate these requests\n+  concurrently, and you're interested in handling all the results, not just the\n+  latest one.\n </p>\n <pre><code class=\"language-html\" [highlight]=\"code4\"></code></pre>\n <strong>Summary:</strong>\n-<p>In this example, mergeMap is used to initiate multiple dependent requests concurrently. The results from all of these\n-    requests are important, and they are handled separately.</p>\n+<p>\n+  In this example, mergeMap is used to initiate multiple dependent requests\n+  concurrently. The results from all of these requests are important, and they\n+  are handled separately.\n+</p>\n \n-<p>This contrasts with a use case for switchMap, where you would only be interested in the result of the latest\n-    observable.\n-    By using mergeMap, you're able to handle complex scenarios where multiple concurrent operations are required, and\n-    all\n-    results are relevant.</p>\n+<p>\n+  This contrasts with a use case for switchMap, where you would only be\n+  interested in the result of the latest observable. By using mergeMap, you're\n+  able to handle complex scenarios where multiple concurrent operations are\n+  required, and all results are relevant.\n+</p>\n \n-<p>This pattern is particularly useful in applications where various parts of the UI depend on different data sets, and\n-    you\n-    want to initiate loading of these data sets concurrently to optimize the loading time.</p>\n+<p>\n+  This pattern is particularly useful in applications where various parts of the\n+  UI depend on different data sets, and you want to initiate loading of these\n+  data sets concurrently to optimize the loading time.\n+</p>\n"
                },
                {
                    "date": 1692727885194,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,4 +64,16 @@\n     This pattern is particularly useful in applications where various parts of the\n     UI depend on different data sets, and you want to initiate loading of these\n     data sets concurrently to optimize the loading time.\n </p>\n+\n+\n+<h4>1. Handling User Interactions (Autocomplete)</h4>\n+<pre><code class=\"language-html\" [highlight]=\"code5\"></code></pre>\n+<h4>2. Managing Multiple Asynchronous Operations</h4>\n+<pre><code class=\"language-html\" [highlight]=\"code6\"></code></pre>\n+<h4>3. State Management (Example with NgRx)</h4>\n+<pre><code class=\"language-html\" [highlight]=\"code7\"></code></pre>\n+<h4>4. WebSockets and Real-Time Communication</h4>\n+<pre><code class=\"language-html\" [highlight]=\"code8\"></code></pre>\n+<h4>5. Animations and Time-Based Operations</h4>\n+<pre><code class=\"language-html\" [highlight]=\"code9\"></code></pre>\n"
                }
            ],
            "date": 1692725995968,
            "name": "Commit-0",
            "content": "<p>rxjs-dashboard works!</p>\n<pre><code class=\"language-html\" [highlight]=\"code\"></code></pre>\n"
        }
    ]
}