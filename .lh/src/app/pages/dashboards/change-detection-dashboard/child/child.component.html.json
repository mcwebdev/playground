{
    "sourceFile": "src/app/pages/dashboards/change-detection-dashboard/child/child.component.html",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1692210161134,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1692212490441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,2 +1,2 @@\n-<p>child works!</p>\n+\n  <div>{{ message.text }}, {{message.timestamp}}</div>\n"
                },
                {
                    "date": 1692212495756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,2 +1,1 @@\n-\n  <div>{{ message.text }}, {{message.timestamp}}</div>\n"
                },
                {
                    "date": 1692213194448,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,1 @@\n- <div>{{ message.text }}, {{message.timestamp}}</div>\n+ <p>{{ message.text }}, {{message.timestamp}}</p>\n"
                },
                {
                    "date": 1692213864241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,26 @@\n- <p>{{ message.text }}, {{message.timestamp}}</p>\n+<p>{{ message.text }}, {{message.timestamp}}</p>\n+\n+<p>In Angular, ChangeDetectionStrategy is a concept that determines how and when Angular checks for changes in component\n+    data and updates the view accordingly. There are two main change detection strategies: Default and OnPush.</p>\n+\n+<h3>Default Change Detection Strategy:</h3>\n+<p>This is the default behavior of Angular's change detection. In this strategy, Angular automatically checks for\n+    changes\n+    in component data during various events like user interactions, HTTP requests, timers, etc. Any change in the\n+    component's data will trigger a re-evaluation of the template and update the view accordingly.</p>\n+\n+<h3>OnPush Change Detection Strategy:</h3>\n+<p>With the OnPush strategy, Angular only checks for changes if the component's input properties (@Input) change, or if\n+    an\n+    event bound with @Output emits an event. This can lead to significant performance improvements, especially in\n+    applications with complex component trees or heavy rendering.</p>\n+\n+<p>Using the <strong>OnPush</strong> strategy requires careful management of component state to ensure that changes are\n+    propagated\n+    correctly. It's effective when the component's data doesn't change frequently and can lead to better performance due\n+    to\n+    fewer change detection checks.</p>\n+\n+<p>In addition to these strategies, you can also create custom change detection strategies if needed. The choice of\n+    strategy depends on the specific requirements of your application and the nature of your components' data and\n+    interactions.</p>\n"
                },
                {
                    "date": 1692213906133,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,26 +1,38 @@\n-<p>{{ message.text }}, {{message.timestamp}}</p>\n+<p>{{ message.text }}, {{ message.timestamp }}</p>\n \n-<p>In Angular, ChangeDetectionStrategy is a concept that determines how and when Angular checks for changes in component\n-    data and updates the view accordingly. There are two main change detection strategies: Default and OnPush.</p>\n+<p>\n+  In Angular, ChangeDetectionStrategy is a concept that determines how and when\n+  Angular checks for changes in component data and updates the view accordingly.\n+  There are two main change detection strategies: Default and OnPush.\n+</p>\n \n <h3>Default Change Detection Strategy:</h3>\n-<p>This is the default behavior of Angular's change detection. In this strategy, Angular automatically checks for\n-    changes\n-    in component data during various events like user interactions, HTTP requests, timers, etc. Any change in the\n-    component's data will trigger a re-evaluation of the template and update the view accordingly.</p>\n+<p>\n+  This is the default behavior of Angular's change detection. In this strategy,\n+  Angular automatically checks for changes in component data during various\n+  events like user interactions, HTTP requests, timers, etc. Any change in the\n+  component's data will trigger a re-evaluation of the template and update the\n+  view accordingly.\n+</p>\n \n <h3>OnPush Change Detection Strategy:</h3>\n-<p>With the OnPush strategy, Angular only checks for changes if the component's input properties (@Input) change, or if\n-    an\n-    event bound with @Output emits an event. This can lead to significant performance improvements, especially in\n-    applications with complex component trees or heavy rendering.</p>\n+<p>\n+  With the OnPush strategy, Angular only checks for changes if the component's\n+  input properties (@Input) change, or if an event bound with @Output emits an\n+  event. This can lead to significant performance improvements, especially in\n+  applications with complex component trees or heavy rendering.\n+</p>\n \n-<p>Using the <strong>OnPush</strong> strategy requires careful management of component state to ensure that changes are\n-    propagated\n-    correctly. It's effective when the component's data doesn't change frequently and can lead to better performance due\n-    to\n-    fewer change detection checks.</p>\n+<p>\n+  Using the <strong>OnPush</strong> strategy requires careful management of\n+  component state to ensure that changes are propagated correctly. It's\n+  effective when the component's data doesn't change frequently and can lead to\n+  better performance due to fewer change detection checks.\n+</p>\n \n-<p>In addition to these strategies, you can also create custom change detection strategies if needed. The choice of\n-    strategy depends on the specific requirements of your application and the nature of your components' data and\n-    interactions.</p>\n+<p>\n+  In addition to these strategies, you can also create custom change detection\n+  strategies if needed. The choice of strategy depends on the specific\n+  requirements of your application and the nature of your components' data and\n+  interactions.\n+</p>\n"
                },
                {
                    "date": 1692213912319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,38 +1,38 @@\n <p>{{ message.text }}, {{ message.timestamp }}</p>\n \n <p>\n-  In Angular, ChangeDetectionStrategy is a concept that determines how and when\n-  Angular checks for changes in component data and updates the view accordingly.\n-  There are two main change detection strategies: Default and OnPush.\n+    In Angular, ChangeDetectionStrategy is a concept that determines how and when\n+    Angular checks for changes in component data and updates the view accordingly.\n+    There are two main change detection strategies: Default and OnPush.\n </p>\n \n <h3>Default Change Detection Strategy:</h3>\n <p>\n-  This is the default behavior of Angular's change detection. In this strategy,\n-  Angular automatically checks for changes in component data during various\n-  events like user interactions, HTTP requests, timers, etc. Any change in the\n-  component's data will trigger a re-evaluation of the template and update the\n-  view accordingly.\n+    This is the default behavior of Angular's change detection. In this strategy,\n+    Angular automatically checks for changes in component data during various\n+    events like user interactions, HTTP requests, timers, etc. Any change in the\n+    component's data will trigger a re-evaluation of the template and update the\n+    view accordingly.\n </p>\n \n <h3>OnPush Change Detection Strategy:</h3>\n <p>\n-  With the OnPush strategy, Angular only checks for changes if the component's\n-  input properties (@Input) change, or if an event bound with @Output emits an\n-  event. This can lead to significant performance improvements, especially in\n-  applications with complex component trees or heavy rendering.\n+    With the OnPush strategy, Angular only checks for changes if the component's\n+    input properties (@Input) change, or if an event bound with @Output emits an\n+    event. This can lead to significant performance improvements, especially in\n+    applications with complex component trees or heavy rendering.\n </p>\n \n <p>\n-  Using the <strong>OnPush</strong> strategy requires careful management of\n-  component state to ensure that changes are propagated correctly. It's\n-  effective when the component's data doesn't change frequently and can lead to\n-  better performance due to fewer change detection checks.\n+    Using the <strong>OnPush</strong> strategy requires careful management of\n+    component state to ensure that changes are propagated correctly. It's\n+    effective when the component's data doesn't change frequently and can lead to\n+    better performance due to fewer change detection checks.\n </p>\n \n <p>\n-  In addition to these strategies, you can also create custom change detection\n-  strategies if needed. The choice of strategy depends on the specific\n-  requirements of your application and the nature of your components' data and\n-  interactions.\n+    In addition to these strategies, you can also create custom change detection\n+    strategies if needed. The choice of strategy depends on the specific\n+    requirements of your application and the nature of your components' data and\n+    interactions.\n </p>\n"
                },
                {
                    "date": 1692214088099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,38 @@\n+<p class=\"message\">{{ message.text }}, {{ message.timestamp }}</p>\n+\n+<p>\n+    In Angular, ChangeDetectionStrategy is a concept that determines how and when\n+    Angular checks for changes in component data and updates the view accordingly.\n+    There are two main change detection strategies: Default and OnPush.\n+</p>\n+\n+<h3>Default Change Detection Strategy:</h3>\n+<p>\n+    This is the default behavior of Angular's change detection. In this strategy,\n+    Angular automatically checks for changes in component data during various\n+    events like user interactions, HTTP requests, timers, etc. Any change in the\n+    component's data will trigger a re-evaluation of the template and update the\n+    view accordingly.\n+</p>\n+\n+<h3>OnPush Change Detection Strategy:</h3>\n+<p>\n+    With the OnPush strategy, Angular only checks for changes if the component's\n+    input properties (@Input) change, or if an event bound with @Output emits an\n+    event. This can lead to significant performance improvements, especially in\n+    applications with complex component trees or heavy rendering.\n+</p>\n+\n+<p>\n+    Using the <strong>OnPush</strong> strategy requires careful management of\n+    component state to ensure that changes are propagated correctly. It's\n+    effective when the component's data doesn't change frequently and can lead to\n+    better performance due to fewer change detection checks.\n+</p>\n+\n+<p>\n+    In addition to these strategies, you can also create custom change detection\n+    strategies if needed. The choice of strategy depends on the specific\n+    requirements of your application and the nature of your components' data and\n+    interactions.\n+</p>\n"
                },
                {
                    "date": 1692217157565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,26 @@\n <p class=\"message\">{{ message.text }}, {{ message.timestamp }}</p>\n \n+<code>\n+    // When using changeDetection: ChangeDetectionStrategy.OnPush, the component will only be\n+    // updated when the input reference changes. You can not update the input object and expect\n+    // the component to be updated. You need to create a new object and assign it to the input\n+    // property. This is because the OnPush strategy will only check for reference changes, not\n+    // property changes.\n+    \n+    // updateMessage() {\n+    // this.message.text = 'Updated message';\n+    // this.message.timestamp = new Date();\n+    // }\n+    \n+    updateMessage() {\n+    this.message = {\n+    //...this.message, use the ... operator to copy the properties of the old object\n+    text: 'Updated message',\n+    timestamp: new Date(),\n+    };\n+    }\n+</code>\n <p>\n     In Angular, ChangeDetectionStrategy is a concept that determines how and when\n     Angular checks for changes in component data and updates the view accordingly.\n     There are two main change detection strategies: Default and OnPush.\n"
                },
                {
                    "date": 1692217222563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n <p class=\"message\">{{ message.text }}, {{ message.timestamp }}</p>\n \n-<pre>\n+<textarea readonly>\n     // When using changeDetection: ChangeDetectionStrategy.OnPush, the component will only be\n     // updated when the input reference changes. You can not update the input object and expect\n     // the component to be updated. You need to create a new object and assign it to the input\n     // property. This is because the OnPush strategy will only check for reference changes, not\n@@ -18,9 +18,9 @@\n     text: 'Updated message',\n     timestamp: new Date(),\n     };\n     }\n-</pre>\n+</textarea>\n <p>\n     In Angular, ChangeDetectionStrategy is a concept that determines how and when\n     Angular checks for changes in component data and updates the view accordingly.\n     There are two main change detection strategies: Default and OnPush.\n"
                },
                {
                    "date": 1692217309760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,17 +7,17 @@\n     // property. This is because the OnPush strategy will only check for reference changes, not\n     // property changes.\n     \n     // updateMessage() {\n-    // this.message.text = 'Updated message';\n-    // this.message.timestamp = new Date();\n+    //      this.message.text = 'Updated message';\n+    //      this.message.timestamp = new Date();\n     // }\n     \n     updateMessage() {\n     this.message = {\n-    //...this.message, use the ... operator to copy the properties of the old object\n-    text: 'Updated message',\n-    timestamp: new Date(),\n+        //...this.message, use the ... operator to copy the properties of the old object\n+        text: 'Updated message',\n+        timestamp: new Date(),\n     };\n     }\n </textarea>\n <p>\n"
                }
            ],
            "date": 1692210161134,
            "name": "Commit-0",
            "content": "<p>child works!</p>\n <div>{{ message.text }}, {{message.timestamp}}</div>\n"
        }
    ]
}